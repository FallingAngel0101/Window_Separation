# ADR 001: Выбор фронтенд-фреймворка (React)

**Статус:** Принят

## Контекст

Требуется создать интуитивно понятный интерфейс для управления несколькими окнами в одном браузерном экране. Ключевые требования:
- Поддержка динамического изменения макета (drag-and-drop).
- Высокая производительность при работе с 4+ окнами.
- Интеграция с разными браузерами (Chrome, Firefox, Edge).

## Решение

Выбран React + Window Management Library (например, react-grid-layout).

## Обоснование

**React:**
- Виртуальный DOM для быстрого рендеринга.
- Поддержка компонентного подхода (каждое окно — независимый компонент).
- Богатая экосистема (готовые решения для drag-and-drop).

**react-grid-layout:**
- Гибкое управление сеткой окон.
- Поддержка адаптивности.

## Альтернативы

| Вариант         | Плюсы                     | Минусы                          |
|-----------------|---------------------------|----------------------------------|
| Vue + VueDraggable | Простота настройки        | Меньше готовых UI-библиотек      |
| Svelte         | Высокая производительность | Ограниченная совместимость       |

## Последствия

**Плюсы:**
- Быстрая разработка за счет готовых компонентов.
- Поддержка сложных сценариев.

**Минусы:**
- Размер бандла

# ADR 002: Выбор клиентского и серверного хранилища для настроек пользователя  
**Статус:** Принято 

## 1. Контекст  
Требуется реализовать:  
- **Клиентское кэширование:** Хранение настроек окон (размеры, позиции, URL) для офлайн-доступа и мгновенной загрузки.  
- **Серверное хранилище:** Резервное копирование (раз в день) и синхронизация между устройствами.  

### Критерии выбора:  
| Критерий          | Клиентская сторона               | Серверная сторона                 |  
|-------------------|----------------------------------|-----------------------------------|  
| Объем данных      | ≥ 10 МБ на пользователя          | Неограниченно (облако)            |  
| Скорость доступа  | Мгновенно (локально)             | Зависит от сети (100-500 мс)      |  
| Структура данных  | JSON (сложные объекты)           | Документно-ориентированная        |  
| Offline-поддержка | Обязательно                      | Не требуется                      |  

## 2. Решения  
### 2.1. Клиентское хранилище: IndexedDB  
**Почему:**  
- Поддержка во всех современных браузерах (Chrome, Firefox, Edge, Safari).  
- Асинхронная работа (не блокирует UI).  
- Лимит ≈ 50% свободного места диска (практически неограниченно).  

### 2.2. Серверное хранилище: MongoDB Atlas  
**Почему:**  
- Гибкость схемы: Настройки окон могут меняться со временем (новые поля, форматы).  
- Бессерверный режим: Автомасштабирование под нагрузку (нет ручного администрирования).  
- Георепликация: Данные доступны из любого региона.  

## 3. Альтернативы  
### Для клиента:  
| Технология    | Плюсы                  | Минусы                     |  
|---------------|------------------------|----------------------------|  
| LocalStorage  | Простота использования | Лимит 5 МБ, только строки  |  
| Cookies       | Работает везде         | 4 КБ на домен              |  

### Для сервера:  
| Технология    | Плюсы                  | Минусы                     |  
|---------------|------------------------|----------------------------|  
| PostgreSQL    | ACID-транзакции        | Избыточен для JSON-данных  |  
| Firestore     | Реальное время         | Привязка к Google Cloud    |  

## 4. Интеграция и синхронизация  
**Сценарий работы:**  
1. **При загрузке плагина:**  
   - Данные грузятся из IndexedDB → мгновенный старт.  
   - В фоне идет синхронизация с сервером (если есть сеть).  
2. **При изменении настроек:**  
   - Сначала обновляется IndexedDB.  
   - Затем асинхронно отправляется на сервер.  

## 5. Последствия  
**Плюсы:**  
- Offline-first: Работа без интернета без потери функциональности.  
- Масштабируемость: MongoDB Atlas справится с ростом пользователей.  

**Минусы:**  
- Сложность синхронизации: Нужна обработка конфликтов.  
- Цена MongoDB Atlas: Бессерверный режим дороже на высоких нагрузках.  

**Компромиссы:**  
Жертвуем строгостью реляционной БД (PostgreSQL) ради удобства работы с JSON.  

## 6. Итоговый выбор  
| Роль            | Технология      | Обоснование                                  |  
|-----------------|-----------------|----------------------------------------------|  
| Клиентский кэш  | IndexedDB       | Поддержка сложных данных + офлайн            |  
| Серверная БД    | MongoDB Atlas   | Гибкость и автомасштабирование               |  


# ADR 003: Мониторинг системы (Prometheus + Grafana)
**Статус:** Принято   

## 1. Контекст  
Необходимо отслеживать:  
- **Производительность MongoDB Atlas** (запросы, репликация, использование RAM)  
- **Работу API** (задержки, ошибки 4xx/5xx)  
- **Клиентскую синхронизацию** (частота конфликтов, размер данных в IndexedDB)  

## 2. Решение: Prometheus + Grafana  
### 2.1. Выбранные компоненты  
| Компонент      | Роль                | Интеграция с текущим стеком          |  
|----------------|---------------------|--------------------------------------|  
| Prometheus     | Сбор метрик         | Pull-модель (раз в 15 сек)           |  
| Grafana        | Визуализация        | Готовые дашборды для MongoDB         |  
| Alertmanager   | Уведомления         | Slack/Telegram/Email                 |  

### 2.2. Источники метрик  
**Для MongoDB Atlas:**  
- **Database Metrics:**  
  - `mongodb_opcounters` (запросы в секунду)  
  - `mongodb_memory_usage` (RES, virtual, mapped)  
  - `mongodb_replset_lag` (задержка репликации)  
- **Custom Exporters:**  
  - MongoDB Exporter: Сбор специфичных метрик (например, размер коллекций)  
  - Node Exporter: Мониторинг сервера (CPU, RAM, disk)  

**Для API (Node.js):**  
- **Express Prometheus Middleware:**  
  - `http_request_duration_seconds` (гистограмма)  
  - `http_requests_total` (счетчик по методам и статусам)  
- **Business Logic Metrics:**  
  - `sync_conflicts_total` (количество конфликтов версий)  
  - `user_sessions_active` (текущие сессии)  

**Для клиентов (опционально):**  
- Размер IndexedDB: через `navigator.storage.estimate()`  
- Частота синхронизации: события отправляются через `/metrics` эндпоинт  

## 3. Файлы мониторинга и их размер  
### 3.1. Prometheus  
| Файл               | Назначение                          | Примерный размер |  
|--------------------|------------------------------------|------------------|  
| `prometheus.yml`   | Конфиг targets и scrape интервалов  | 2-5 KB           |  
| `rules/alerts.yml` | Правила алертов (например, 5xx > 1%) | 10-20 KB        |  
| `data/` (TSDB блоки) | Хранилище метрик                 | 1-10 GB/месяц    |  

**Расчет объема данных:**  
- Метрик/сек: ~500 (при 10 RPS на API)  
- Размер точки данных: ~2 байта  
- Итого: `500 * 86400 * 30 * 2 ≈ 2.5 GB/месяц + overhead`  

### 3.2. Grafana  
| Файл                   | Назначение               | Примерный размер |  
|------------------------|--------------------------|------------------|  
| `dashboards/mongo.json` | Дашборд для MongoDB      | 50-100 KB        |  
| `dashboards/api.json`   | Дашборд для API          | 30-70 KB         |  
| `provisioning/`         | Конфиги datasources/dashboards | 5-10 KB     |  

## 4. Альтернативы  
| Вариант        | Плюсы                     | Минусы                        |  
|---------------|---------------------------|-------------------------------|  
| ELK Stack     | Гибкий анализ логов       | Требует ~3x ресурсов          |  
| Datadog      | Облачное решение "из коробки" | $15/хост/месяц             |  
| VictoriaMetrics | Экономичнее Prometheus  | Меньше интеграций             |  

**Почему не ELK?**  
- Избыточен для метрик (лучше подходит для логов)  
- Требует отдельного кластера Elasticsearch  

## 5. Итоги  
| Компонент     | Технология    | Обоснование                              |  
|--------------|--------------|------------------------------------------|  
| Сбор метрик  | Prometheus   | Открытый исходный код + Pull-модель      |  
| Визуализация | Grafana      | Готовые дашборды для MongoDB             |  
| Алертинг     | Alertmanager | Интеграция с Slack/Email                 |  

